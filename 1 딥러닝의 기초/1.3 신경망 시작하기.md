## 3 신경망 시작하기

----

### 신경망의 구조

* 층 : 딥러닝의 구성 단위
	* 텐서를 입력으로 받아 텐서를 출력하는 데이터 처리 모듈
	* 가중치(: 층의 상태, 확률적 경사 하강법에 의해 학습되는 텐서, 네트워크가 학습한 지식 담김) 가짐
	* 층 호환성 layer compatibility : 각 층이 특정 크기의 입력 텐서만 받고 특정 크기의 출력 텐서 반환

* 모델 : 층의 네트워크
	* 딥러닝 모델 : 층으로 만든 비순환 유향 그래프 Directed Acyclic Graph (DAG)
	* 네트워크 구조 => 가설 공간 hypothesis space 정의 (==가능성 있는 공간)

* 손실 함수 & 옵티마이저 : 학습 과정 조절
	* 손실 함수 loss function / 목적 함수 objective function: 훈련하는 동안 최소화될 값, 주어진 문제에 대한 성공 지표
	* 옵티마이저 optimizer : 손실 함수 기반 네트워크 업데이트 결정, 확률적 경사 하강법 구현

----

### 케라스

* 케라스 : 모든 종류의 딥러닝 모델을 간편하게 만들고 훈련시킬 수 있는 파이썬 딥러닝 프레임워크
	* CPU & GPU 실행
	* 쉬운 API
	* 합성곱 신경망, 순환 신경망 지원
	* 모든 네트워크 구조 생성 가능

* 개발 순서
	* 1 입력 텐서 & 타깃 텐서로 이루어진 훈련 데이터 정의
	* 2 모델 정의 : 입력과 타깃을 매핑하는 층으로 이루어진 네트워크 정의
		* 1) Sequential 클래스 사용
			model = model.Sequential()
		* 2) 함수형 API 사용
			model = models.Model(input=input_tensor, outpts=output_tensor)
	* 3 컴파일 단계 : 손실 함수, 옵티마이저, 모니터링하기 위한 지표를 선택하여 학습 과정 설정
		* model.compile(optimizer=optimizer.RMSprop(lr=0.001), loss='mse', metrics=['accuracy'])
	* 4 학습 과정 : 훈련 데이터에 대해 fit() 메서드를 반복 호출
		model.fit(input_tensor, target_tensor, batch_size=128, epochs=10)

----

### 이진 분류 예제 : 영화 리뷰 분류
2종 분류 two-class classification / 이진 분류 binary classification
리뷰 텍스트 기반 영화 리뷰를 긍정, 부정으로 분류하는 방법

* IMDB 데이터셋
- 인터넷 영화 데이터베이스로부터 가져온 양극단의 리뷰 6만 개로 이루어진 IMDB 데이터셋 사용
- 25000개 훈련 데이터, 25000개 테스트 데이터(새로운 데이터에 대한 모델의 성능 측정)
- 50% 긍정, 50% 부정
- 전처리 되어 있어 각 리뷰가 숫자 시퀀스(사전의 고유 단어)로 변환되어 있음

#### IMDB 데이터셋 로드하기
(train_data, train_label), (test_data, train_label) = imdb.load_data(num_words=10000)
// data에는 리뷰 목록 저장, label에는 부정 0 긍정 1 저장

* 데이터 준비
- 같은 길이가 되도록 리스트에 패딩 padding 추가
- 리스트를 원-핫 인코딩 one-hot encoding하여 0과 1의 벡터로 변환

#### 정수 시퀀스를 이진 행렬로 인코딩
def vectorize_sequences(sequences, dimension=10000):
	results = np.zeros((len(sequences), dimension))
	for i, sequence in enumerate(sequences):
		results[i, sequence] = 1.
	return results

x_train = vectorize_sequences(train_data)
x_test = vectorize_sequences(test_data)

y_train = np.asarray(train_labels).astype('float32')
y_test = np.asarray(test_labels).astype('float32')

* 신겸망 모델 만들기
- 입력 데이터 : 벡터, 레이블 : 스칼라 (0, 1)
- 간단한 문제에서 잘 작동하는 네트워크 : relu 활성화 함수를 사용한 완전 연결 층을 쌓은 것
 => Dense(은닉유닛개수, activation='relu')
	* 은닉유닛 hidden layer : 층이 나타내는 표현 공간에서 하나의 차원
	* 고려 요소
		* 사용할 층의 개수
		* 각 층의 은닉 유닛 개수
	* relu : 음수를 0으로 만드는 함수, 시그모이드 함수 : 임의의 값을 [0, 1] 사이로 압축해 출력

#### 모델 정의하기
model = models.Sequential()
model.add(layers.Dense(16, activation='relu', input_shape(10000,)))
model.add(layers.Dense(16, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))

** 활성화 함수
	* 사용 이유: Dense 층은 선형적인 연산인 점곱과 덧셈 2개로 구성 => 선형 변환만을 학습 가능 => 제약 많음, 층을 추가해도 가설 공간이 확장 X
output = dot(W, input) + b
	* 가설 공간을 풍부하게 만들어 층을 깊게 만드는 장점을 살리기 위해 비선형성, 활성화 함수 추가
	* ex) relu, prelu, elu

- 손실 함수, 옵티마이저 선택

#### 모델 컴파일 하기
model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['accuracy'])

#### 옵티마이저 설정하기
model.compile(optimizer=optimizers.RMSprop(lr=0.001),loss='binary_crossentropy', metrics=['accuracy'])

#### 손실, 측정을 함수 객체로 지정
models.compile(optimizer=optimizers.RMSprop(lr-0.001), loss=losses.binary_crossentropy, metrics=[metrics.binary_accuracy])

* 훈련 검증
- 모델의 정확도 측정 위해 원본 훈련 데이터에서 샘플을 떼어 검증 세트 만듦

#### 검증 세트 준비
x_val = x_train[:10000]
partial_x_train = x_train[10000:]
y_val = y_train[:10000]
partial_y_train = y_train[10000:]

#### 모델 훈련하기
model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['acc'])
history = model.fit(partial_x_train, partial_y_train, epochs=20, batch_size=512, validation_data(x_val, y_val))

#### 훈련과 검증 손실 그리기
history_dict = history.history
loss = history_dict['loss']
val_loss = history_dict['val_loss']

epochs = range(1, len(loss) + 1)

plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.show()

#### 훈련과 검증 정확도 그리기
plt.clf() // 그래프 초기화
acc = history_dict['acc']
val_acc = history_dict['val_acc']

plt.plot(epochs, acc, 'bo', label='Training acc')
plt.plot(epochs, val_acc, 'b', label='Validation acc')
plt.title('Training and validation accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')

plt.show()







